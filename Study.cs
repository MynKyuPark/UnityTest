// C# 언어에서 전처리기 명령어를 사용하기 위해서는 반드시 파일 최상단에 위치 시켜야 한다.

//#define EXAMPLE_TYPE_VALUE
//#define EXAMPLE_TYPE_REFERENCE
#define EXAMPLE_TYPE_NULLABLE

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

// C# != C# Script

#region C# Basic
/*
    ▶ C# 언어의 문법을 숙지해야 하는 이유

    - 유니티 엔진에서 기본적으로 스크립트는 대부분 C# 스크립트를 이용하기 때문에 유니티 엔진의 활용성을 높히기 위해서는 C# 언어에 대한 지식이 필수로 필요하다.
    C / C++ 스타일로 C# 문법을 모르고 작성하는 것도 가능하지만 결국엔 한계에 부딛히게 된다.

    ★★★★★
    ▶ C# 프로그램 동작 방식

    - C# 프로그램은 CLR (Common Language Runtime) 이라는 자바의 가상 머신과 비슷한 프로그램 위에 구동이 된다.
    C / C++ 언어와 달리 결과물이 컴퓨터가 바로 실행 할 수 있는 실행 파일로 생성되지 않는다는 것을 의미한다. 
    
    ★ CLR (Common Language Runtime)
        ㄴ 마이크로 소프트에서 개발한 가상 머신의 구성요소 (Windows 전용)
        ㄴ 기능은 크게 2가지로 말할 수 있다.
            ㄴ 1. 중간언어를 JIT 라는 컴파일러를 이용해서 기계어로 변환 가능
            ㄴ 2. 가비지 컬렉션을 통한 동적 메모리 관리
            
가상 머신 (Virtual Machine):
ㄴ 컴퓨터에서 가상으로 사용하는 컴퓨터
ㄴ 컴퓨터에서 1대 이상의 컴퓨터를 구동하는 것으로 하드웨어 등 모든 컴퓨터 자원을 가상화 시킨 것

    ㄴ C# 은 CLR 이라는 중간 과정을 거쳐서 다른 언어를 사용할 수 있게 지원을 한다.
    ㄴ CLE 은 CIT 코드를 읽어들여 OS가 이해할 수 있는 Native Code로 변환하는 역할을 한다.
    ㄴ 이떄 서로 다른 언어들이 만나는 지점이 IL 이라는 중간 언어이며 이 언어로 쓰여진 코드를 다시 CLR이 자신이 실행한 플랫폼으로 맞춰서 컴파일을 하는 구조

※ 요약하면 CLR 은 따로 컴파일을 해서 실행을 시키고 그걸 해당 플랫폼에 다시 맞춰서 컴파일을 하게 하는 기능을 뜻한다. 
※ 참고로 C / C++ 은 컴파일을 진행해서 프로그램을 바로 만들어 낸다.

CIL (Common Intermediate Language : 공통 중간 언어):
ㄴ 닷넷 프레임워크에서 실행되는 언어
ㄴ 닷넷 프레임워크 언어로 개발된 프로그램 코드는 컴파일 시 바이너리 형태로 CIT 라는 파일로 작성된다

엔진의 정의 : 라이브러리의 집합 + 툴

※ .Net FrameWork:
ㄴ Windows 프로그램 개발 및 실행 환경
네트워크 작업, 인터페이스 등의 많은 작업을 캡슐화하여 코딩의 효율을 올려준다.
특징으로는 CLS (닷넷 프레임워크의 언어가 반드시 지켜야 하는 언어 스펙) 을 따르는 언어라면 어떠한 언어라도 닷넷 프레임워크에서 실행이 가능하며
CLR 이라는 가상 기계위에서 작동하기 떄문에 플랫폼에서 독립적이며 궁극적으로는 프로그래머가 코딩을 하는데 더 편한 환경을 제공한다.

그리고 CLR 구동중에 IL 코드를 읽어들여서 특정 운영체제에 맞는 네이티브 코드로 변환시켜주는 작업을 JIT (Just In Time 컴파일 방식) 이라고 한다.

★
즉, C# 프로그램은 컴파일 방식 + 인터프리트 방식의 혼합 하이브리드 방식으로 구동된다.

★ 실행 순서:
C# 컴파일 -> IL 생성 -> CLR -> 실행파일


▶ JIT 컴파일 방식의 장점

- 프로그램이 구동 중에 즉시 네이티브 코드를 생성하기 때문에 특정 운영체제에 맞는 최적화 코드를 만들어 내는것이 가능하다.


▶ JIT 컴파일 방식의 단점

- 프로그램이 구동중에 네이티브를 생성하기 때문에 해당 코드를 생성하기 위한 시간이 필요하다.

▶ CLR의 두드러지는 3가지 역할
ㄴ 메모리 관리 (가비지 컬렉션)
ㄴ 예외 처리
ㄴ 프로그래밍 언어간의 호환성 
    ㄴ .Net FrameWork는 C# 언어만 위한 프레임 워크가 아니기 때문에 C# 언어를 제외한 다른 언어에서도 닷넷 프레임워크를 이용하는것이 가능하다.
       이때 발생하는 언어간의 문법적인 차이를 CLR을 통해서 통일화 시키는 것이 가능

▶ C# 언어가 다른 언어와 호환이 가능한 이유:

- C# 언어는 낸부적으로 CTS (Common Type System) 규칙에 따라 데이터 타입을 구현하기 때문에


※ CTS (Common Type System):
ㄴ 공용 타입 시스템
ㄴ 닷넷 호환 언어가 지켜야 할 타입의 표준 규격으로 닷넷 호환 언어를 만든다면 CTS 규격을 반드시 지켜야 한다.
ㄴ CTS를 모두 만들 필요는 없지만 필요한 규격만 지원해도 되며 CTS 규격을 벗어나는 새로운 타입은 만들 수 없다.

▶ C# 프로그램의 메모리 관리 방식 (가비지 컬렉션):

1. 스택 메모리 관리 (정적)
2. 힙 메모리 관리 (동적)

- C# 언어는 힙 메모리를 프로그래머가 직접적으로 관리하는 C / C++ 언어와 달리 C# 언어의 힙 메모리는 가비지 컬렉션에 의해서 관리가 된다.
(즉, 메모리 릭을 염두하지 않고 프로그램 로직을 구성하는 것이 가능하다.)

▶ 스택 메모리의 특징

- 스택 메모리는 지역적인 특징을 지니고 있기 때문에 "시스템에 의해서 메모리가 관리" 된다.
(즉, 스택에 할당 된 메모리는 따로 관리하기 위한 로직이 불필요하다.)


▶ 힙 메모리의 특징

- C / C++ 언어와는 달리 C# 언어에서 힙 메모리는 프로그래머에 의해서 직접적으로 관리되지 않는다.
(즉, 해당 메모리 영역은 가비지 컬렉션에 의해서 관리가 된다.)


▶ 가비지 컬렉션에 의한 메모리 관리 방식의 장점                         //메모리관리 핵심//

- 메모리 릭을 염두하지 않고 프로그램 로직을 구성하는 것이 가능하기 때문에 편하다. 


▶ 가비지 컬렉션에 의한 메모리 관리 방식의 단점

- C# 언어는 힙 메모리는 할당하는 것은 가능하지만 직접적으로 관리되지 않기 떄문에 불필요한 메모리 공간이 있다는 것을 알아도 즉시 제거하는것이 불가능 하다.

- 권한이 없기 떄문에 가비지 컬렉션이 구동 될 때까지 해당 데이터는 메모리에 계속 상주한다.

- 그렇게 때문에 가비지 컬렉션에 의한 메모리 관리는 많은 부하를 일으키는 원인이 된다.
그래서 프로그램을 작성할때는 가비지 컬렉션에 상태에 따라서 신경을 써야한다. (프로그램 로직)
또한, 높은 퍼포먼스를 요구하는 프로그램에서는 최적화에 대한 많은 노력이 필요하다.

▶ C# 언어 자료형의 특징

-C# 언어는 기본적으로 모든 데이터가 클래스 또는 객체로 인식이 된다.
ㄴ c / c++ / c# 자료형의 차이점에 대해서
ㄴ 즉, int, float, duoble 등의 기본 자료형도 c#에서는 내부적으로 클래스로 표현된다는 것을 의미한다.

★
- 또한, C# 언어의 자료형의 데이터 타입에 따라서 값 타입과 참조 타입으로 나뉜다.
- 그리고 데이터의 형식에 따라서 기본 데이터 형식과 복합 데이터 형식으로 구분된다.

복합 데이터 형식 : 
ㄴ 구조체와 클래스 + 배열

▷ 값 형식 데이터 타입의 특징

- 값 형식의 데이터 타입은 스택 메모리에 할당된다.
ㄴ즉, 시스템에 의해서 메모리가 관리된다.

▷ 참조 형식 데이터 타입의 특징

-참조 형식 데이터 타입은 실제적인 값을 스택에 할당하는 값 형식과는 달리 실제 값은 
힙 메모리에 할당되며 해당 메모리에 대한 참조 값을 스택에 할당하는 변수에 보관한다.
ㄴ즉, 참조 형식의 데이터 타입은 가비지 컬렉션에 의해서 메모리가 관리된다.

이는 c# 언어는 기본적으로 다른 언어와의 호환성을 지닐 필요가 있기 때문에 c# 언어의 자료형이 CTS 표준을 따르고 있기 때문

▶ c# 언어의 변수 특징

-c# 언어의 모든 클래스는  object 클래스를 직/간접적으로 상속하는 것이 원칙이다.
ㄴ즉, object 타입의 변수로 모든 데이터를 보관하는 것이 가능

-object 타입을 다른 데이터 형식의 값으로 제어하는 것을 박싱/언박싱이라고 지칭한다.

-박싱은 데이터를 보관하는 행위고 언박싱은 데이터를 읽어들이는 행위이다.        //메모리관리 핵심//

object 타입의 변수는 기본적으로 참조 타입이기 때문에 해당 변수에 참조 타입의 값을 보관할 때는 퍼포먼스 저하를 일으키지 않지만, 값 형식의 데이터를 보관할 때는
박싱/언 박싱이 수행되기 때문에 퍼포먼스 저하가 발생한다.

▷ 값 형식의 종류

- byte, int, long, float(정밀도 : 7), double(정밀도 : 15), decimal(정밀도 : 29 / 연산 느리고 메모리 16byte / 라운딩 에러), char, enum, struct, Nullable

(c 계열 언어는 타입에 매우 엄격한 언어이다)

▷ 참조 형식의 종류 (기본적으로 참조 형식은 null 대입이 가능)

- object, string, class, delegate

▷ 값 형식과 참조 타입의 차이점

- 기본적으로 c#의 object 타입은 모든 데이터를 가르키는 것이 가능하지만 object 타입은 참조 타입에 해당되기 
때문에 해당 타입의 변수에 값 타입의 데이터를 할당할 경우 내부적으로 박싱/언박싱이  발생된다.

- 값 타입의 자료형은 스택에 할당되기 때문에 시스템에 의해서 메모리가 관리되고 값을 할당할 때는 내부적으로 복사가 발생한다.
- 즉, 값 자체가 복사된다. 깊은 복사

- 반면, 참조 타입의 자료형은 힙에 해당되기 때문에 가비지 컬렉션에 의해서 메모리가 관리되고 값을 할당할 때 참조 값을 복사가 이뤄진다.(메모리 주소 할당 - 얕은 복사)

- 단, c# 언어의 문자열은 기본적으로 변경이 불가능하기 때문에 (권한이 없기때문) 
기본 문자열을 편집한 새로운 문자열을 얻기 위해서는 새로운 메모리 공간에 문자열을 생성해야 한다.
-즉, 한 번 할당되어 만들어진 문자열은 더이상 편집이 불가능하다.


▶ Nullable 타입이란 ?

- 기본적으로 c# 언어는 참조 타입 데이터의 유효하지 않는 여부를 null 키워드를 토애서 구분 할 수 있는 반면에 
값 타입의 데이터는 null 키워드를 이용하는 것이 불가능(이는 오류를 미리 방지 할 수 없음을 의미)

- 그렇기 때문에 Nullable 타입이라는 자료혀잉 주어지며 해당 자료형은 값 타입에 null 키워드를 사용할 수 있게 하는 기능을 제공한다.

- Nullable은 값 타입의 데이터에만 사용하는 것이 가능하다.


*/
#endregion

public class Study : MonoBehaviour
{
    public void Awake()
    {
#if EXAMPLE_TYPE_VALUE
        int nValue = 10;
        float fValue = 3.14f;
        double dValue = 3.14;
        decimal mValue = 3.14m;

        Debug.LogFormat("데이터 출력 : {0}, {1}, {2}, {3}", nValue, fValue, dValue, mValue);

#elif EXAMPLE_TYPE_REFERENCE
        object oValue = 10;
        string oString = "Hell Fire";

        /*
         $ : 
        ㄴ c# 6의 추가된 기능
        ㄴ 문자열 보간 (보간된 문자열로 식별하는 기능)
        ㄴ {0}, {1}, ... 과 같이 서식 항목들의 순서를 정해주는 Format() 방법과는 달리 문자열 보간은 string 안에 직접 변수 이름을 할당한다.
         
         */
        Debug.Log($"데이터 출력 : {oValue}, {oString}");

#else
        // c# Nullable 타입은 Null을 가질 수 없는 데이터 타입을 Null을 가질 수 있는 새롭게 만든 타입
        // 선언 방법은 2가지 1. 데이터 타입? // 2. Nullable<int>

        //int nValue = null; 당연히 안됨
        int? nValue = null;
        float? fValue = null;
        System.Nullable<int> nValueB = 10;
        // HashValue : 값이 있으면 t/ 없으면 f(null)
        if(nValue.HasValue)
        {
            Debug.Log("정수형 값이 유효하다.");
        }
        else
        {
            Debug.Log("정수형 값이 유효하지 않다.");
        }

        if (fValue != null)
        {
            Debug.Log("실수형 값이 유효하다.");
        }
        else
        {
            Debug.Log("실수형 값이 유효하지 않다.");
        }

        if (nValueB.HasValue)
        {
            Debug.Log("정수형 값이 유효하다.");
        }
        else
        {
            Debug.Log("정수형 값이 유효하지 않다.");
        }
#endif
    }
}